[{"/home/prncss/Media/Projects/keytrainer/src/index.tsx":"1","/home/prncss/Media/Projects/keytrainer/src/theme.ts":"2","/home/prncss/Media/Projects/keytrainer/src/App.tsx":"3","/home/prncss/Media/Projects/keytrainer/src/components/list.ts":"4","/home/prncss/Media/Projects/keytrainer/src/components/constants.ts":"5"},{"size":332,"mtime":1646763818503,"results":"6","hashOfConfig":"7"},{"size":418,"mtime":1612874521042,"results":"8","hashOfConfig":"7"},{"size":6393,"mtime":1646765079166,"results":"9","hashOfConfig":"7"},{"size":7944,"mtime":1646765340735,"results":"10","hashOfConfig":"7"},{"size":689,"mtime":1646765185399,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"pnoxn0",{"filePath":"15","messages":"16","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21"},{"filePath":"22","messages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/prncss/Media/Projects/keytrainer/src/index.tsx",[],["24","25"],"/home/prncss/Media/Projects/keytrainer/src/theme.ts",[],"/home/prncss/Media/Projects/keytrainer/src/App.tsx",[],"/home/prncss/Media/Projects/keytrainer/src/components/list.ts",["26"],"import { useReducer, useEffect } from 'react';\n\nimport rfdc from 'rfdc';\n\n// see source for definitions\nimport {\n  ratioThreshold,\n  maxDelay,\n  errBias,\n  charactersBefore,\n  maxChartersDisplayed,\n  unrepeatHalfLife,\n  statsHalfLife,\n  charSuccessHalfLife,\n  headGoodThreshold,\n} from './constants';\n\nconst clone = rfdc();\n\nexport type Immutable<T> = {\n  readonly [K in keyof T]: Immutable<T[K]>;\n};\n\ninterface CharStats {\n  errorRatio: number;\n  lastCalledIndex: number | undefined;\n}\n\ninterface PreTarget {\n  value: string;\n  firstTime: boolean;\n}\ntype Target = {\n  index: number;\n} & PreTarget;\n\nexport interface State {\n  completed: boolean; // standards have been met with last character\n  targets: Target[]; // character instances to be typed\n  position: number; // index within targets of character expected to be pressed\n  correct: boolean; // true if last press event was successful\n  succRatio: number; // weighted number of success, any character\n  headGoodCount: number; // number of success with lastly added character\n  sinceNewHeadCount: number; // number of success since lastly added character\n  backstoreCharacters: string[]; // characters that are not active yet, in order\n  lastPressTime?: number; // time of the last press event\n  delayMean?: number; // weighted number of registered events, will equal goodCumul + badCumul\n  head: string; // lastly added character\n  charStatsMatrix: { [character: string]: CharStats };\n  count: number;\n  wantsNewTarget: boolean;\n}\n\n// draw a character with a flat distribution\nfunction drawFlatTarget(state: Immutable<State>, seed: number): string {\n  let pick = seed * (Object.keys(state.charStatsMatrix).length - 1);\n  let key;\n  for (const key0 of Object.keys(state.charStatsMatrix)) {\n    key = key0;\n    if (key === state.targets[state.targets.length - 1]?.value) continue;\n    pick -= 1;\n    if (pick <= 0) return key;\n  }\n  if (!key) throw new Error('Expected non void selection.');\n  return key;\n}\n\nfunction drawWeightedTarget(state: Immutable<State>, seed: number): string {\n  const p = Math.pow(2, -1 / unrepeatHalfLife);\n  const index = state.targets[state.targets.length - 1]?.index + 1 || 0;\n  const weight = ({ errorRatio, lastCalledIndex }: CharStats) => {\n    if (lastCalledIndex === undefined) return errorRatio;\n    return errorRatio * (1 - Math.pow(p, index - lastCalledIndex - 1));\n  };\n  let total = Object.values(state.charStatsMatrix).reduce(\n    (total, charStats) => total + weight(charStats),\n    0,\n  );\n  let pick = seed * total;\n  let key;\n  for (const [key0, charStats] of Object.entries(state.charStatsMatrix)) {\n    key = key0;\n    pick -= weight(charStats);\n    if (pick <= 0) return key;\n  }\n  if (!key) throw new Error('charStatsMatrix should not be empty.');\n  return key;\n}\n\nfunction drawTarget(state: Immutable<State>, seed: number): string {\n  if (\n    state.headGoodCount < headGoodThreshold &&\n    state.targets[state.targets.length - 1]?.value !== state.head &&\n    seed > 0.8\n  )\n    return state.head;\n  // seed /= 0.8;\n  // if (Math.random() > 0.95)\n  // return drawFlatTarget(state, seed / 0.95);\n  return drawWeightedTarget(state, seed / 0.95);\n}\n\nconst updateMean = (\n  newVal: number,\n  mean: number | undefined,\n  halfLife: number,\n) =>\n  mean === undefined\n    ? newVal\n    : Math.pow(2, -1 / halfLife) * (mean - newVal) + newVal;\n\nconst press = (key: string, timeStamp: number) =>\n  ({ type: 'PRESS', key, timeStamp } as const);\n\nconst newRandomTarget = (seed: number) =>\n  ({ type: 'NEW_RANDOM_TARGET', seed } as const);\n// export const newChar = (key: string) => ({ type: 'NEW_CHAR', key } as const);\n\ntype Action = ReturnType<typeof press> | ReturnType<typeof newRandomTarget>;\n\n// adds a character instance to the typing flow\nfunction newTarget(\n  state: Immutable<State>,\n  target: PreTarget,\n  init = false,\n): State {\n  const stateOut = clone(state) as State;\n  // const index = stateOut.targets[stateOut.targets.length - 1]?.index + 1 || 0;\n  ++stateOut.count;\n  stateOut.targets.push({ ...target, index: stateOut.count });\n  stateOut.charStatsMatrix[target.value].lastCalledIndex = stateOut.count;\n  if (stateOut.targets.length > maxChartersDisplayed) {\n    stateOut.targets = stateOut.targets.slice(1);\n  } else {\n    if (!init) ++stateOut.position;\n  }\n  stateOut.wantsNewTarget = false;\n  return stateOut;\n}\n\n// adds a character type to active set\nfunction newCharacter(state: Immutable<State>, init = false): State {\n  const stateOut = clone(state) as State;\n  stateOut.head = state.backstoreCharacters[0];\n  if (!stateOut.head) {\n    stateOut.completed = true;\n    return stateOut;\n  }\n  stateOut.wantsNewTarget = false;\n  stateOut.backstoreCharacters.shift();\n  stateOut.sinceNewHeadCount = 0;\n  stateOut.headGoodCount = 0;\n  stateOut.charStatsMatrix[stateOut.head] = {\n    errorRatio: 1,\n    lastCalledIndex: undefined,\n  };\n  return newTarget(\n    stateOut,\n    {\n      value: stateOut.head,\n      firstTime: true,\n    },\n    init,\n  );\n}\n\nfunction registerCharacterPress(\n  state: State,\n  { key, timeStamp }: ReturnType<typeof press>,\n): State {\n  const target = state.targets[state.position];\n  if (!target) throw new Error('target must not be empty when key pressed');\n  const lastCorrect = state.correct;\n  state.correct = target.value === key;\n  if (lastCorrect) {\n    if (state.correct) {\n      state.succRatio = updateMean(1, state.succRatio, statsHalfLife);\n      state.charStatsMatrix[target.value].errorRatio = updateMean(\n        0,\n        state.charStatsMatrix[target.value].errorRatio,\n        charSuccessHalfLife,\n      );\n      if (state.lastPressTime) {\n        const delay = timeStamp - state.lastPressTime;\n        if (delay < maxDelay) {\n          state.delayMean = updateMean(delay, state.delayMean, statsHalfLife);\n        }\n      }\n      if (target.value === state.head) ++state.headGoodCount;\n    } else {\n      state.succRatio = updateMean(0, state.succRatio, statsHalfLife);\n      state.charStatsMatrix[target.value].errorRatio = updateMean(\n        1,\n        state.charStatsMatrix[target.value].errorRatio,\n        charSuccessHalfLife * errBias,\n      );\n    }\n  }\n\n  state.lastPressTime = timeStamp;\n  return state;\n}\n\nfunction reducer(state: Immutable<State>, action: Action): State {\n  switch (action.type) {\n    case 'PRESS': {\n      const stateOut = clone(state) as State;\n      registerCharacterPress(stateOut, action);\n      if (state.correct) {\n        if (\n          stateOut.correct &&\n          state.succRatio > ratioThreshold &&\n          stateOut.headGoodCount >= headGoodThreshold\n        ) {\n          return newCharacter(stateOut);\n        }\n      }\n      if (stateOut.correct) stateOut.wantsNewTarget = true;\n      return stateOut;\n    }\n    case 'NEW_RANDOM_TARGET': {\n      return newTarget(state, {\n        value: drawTarget(state, action.seed),\n        firstTime: false,\n      });\n    }\n  }\n}\n\nexport default function useList(characters: string) {\n  let state0: State = {\n    targets: [],\n    succRatio: 1,\n    delayMean: undefined,\n    position: 0,\n    correct: true,\n    sinceNewHeadCount: 0,\n    headGoodCount: 0,\n    backstoreCharacters: characters.split(''),\n    completed: false,\n    head: '',\n    charStatsMatrix: {},\n    count: 0,\n    wantsNewTarget: false,\n  };\n  state0 = newCharacter(state0, true);\n  while (state0.targets.length < charactersBefore + 1) {\n    state0 = newTarget(\n      state0,\n      {\n        value: drawTarget(state0, Math.random()),\n        firstTime: false,\n      },\n      true,\n    );\n  }\n\n  const [state, dispatch] = useReducer(reducer, state0);\n\n  // out of reducer because impure (randomness)\n  useEffect(() => {\n    if (state.wantsNewTarget) {\n      dispatch(newRandomTarget(Math.random()));\n    }\n  }, [dispatch, state.wantsNewTarget]);\n\n  const sendKey = (key: string, timeStamp: number) => {\n    if (key.length === 1) {\n      dispatch(press(key, timeStamp));\n    }\n  };\n\n  return [state, sendKey] as [State, typeof sendKey];\n}\n","/home/prncss/Media/Projects/keytrainer/src/components/constants.ts",[],{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":55,"column":10,"nodeType":"33","messageId":"34","endLine":55,"endColumn":24},"no-native-reassign",["35"],"no-negated-in-lhs",["36"],"@typescript-eslint/no-unused-vars","'drawFlatTarget' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]